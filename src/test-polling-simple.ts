/**
 * –ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã Polling
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ—Å–Ω–æ–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å PollingManager
 */

import { PollingManager } from './core/polling/PollingManager';

// Mock –∞–¥–∞–ø—Ç–µ—Ä –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
class MockAdapter {
  private platform: string;
  private pollCount: number = 0;

  constructor(platform: string) {
    this.platform = platform;
  }

  getPlatform() {
    return this.platform as any;
  }

  getCapabilities() {
    return {
      supportsPolling: true,
      supportsWebhooks: false,
      supportsMedia: true,
      supportsInlineButtons: true,
      maxMessageLength: 4096,
      supportedMediaTypes: ['photo', 'video']
    };
  }

  async pollUpdates() {
    this.pollCount++;
    console.log(`    ${this.platform} poll #${this.pollCount}`);
    
    // –°–∏–º—É–ª–∏—Ä—É–µ–º –Ω–µ–±–æ–ª—å—à—É—é –∑–∞–¥–µ—Ä–∂–∫—É
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // –ò–Ω–æ–≥–¥–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    if (this.pollCount === 5) {
      throw new Error(`Mock error for ${this.platform}`);
    }
  }

  emitError(error: Error) {
    console.log(`    ${this.platform} error: ${error.message}`);
  }

  startPolling() {
    // Legacy method
  }

  getPollCount() {
    return this.pollCount;
  }
}

async function testPollingSimple() {
  console.log('üß™ Testing Polling System (Simple)...\n');

  const tests = [
    {
      name: 'Manager Singleton',
      test: testManagerSingleton
    },
    {
      name: 'Default Configurations',
      test: testDefaultConfigurations
    },
    {
      name: 'Basic Polling Operations',
      test: testBasicPollingOperations
    },
    {
      name: 'Configuration Management',
      test: testConfigurationManagement
    },
    {
      name: 'Statistics Collection',
      test: testStatisticsCollection
    },
    {
      name: 'Error Handling',
      test: testErrorHandling
    },
    {
      name: 'Health Monitoring',
      test: testHealthMonitoring
    }
  ];

  let passed = 0;
  let failed = 0;

  for (const test of tests) {
    try {
      console.log(`\nüìã ${test.name}:`);
      await test.test();
      console.log(`‚úÖ ${test.name} - PASSED`);
      passed++;
    } catch (error) {
      console.error(`‚ùå ${test.name} - FAILED:`, error);
      failed++;
    }
  }

  console.log(`\nüìä Polling System Test Results:`);
  console.log(`‚úÖ Passed: ${passed}`);
  console.log(`‚ùå Failed: ${failed}`);
  console.log(`üìà Success Rate: ${((passed / (passed + failed)) * 100).toFixed(1)}%`);

  return { passed, failed };
}

async function testManagerSingleton() {
  console.log('  Testing manager singleton pattern...');

  const manager1 = PollingManager.getInstance();
  const manager2 = PollingManager.getInstance();

  console.log(`    Same instance: ${manager1 === manager2 ? 'Yes' : 'No'}`);

  if (manager1 !== manager2) {
    throw new Error('PollingManager should be a singleton');
  }
}

async function testDefaultConfigurations() {
  console.log('  Testing default configurations...');

  const manager = PollingManager.getInstance();

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º
  const telegramConfig = manager.getDefaultConfig('telegram');
  const maxConfig = manager.getDefaultConfig('max');
  const discordConfig = manager.getDefaultConfig('discord');

  console.log(`    Telegram config: ${telegramConfig ? 'Present' : 'Missing'}`);
  console.log(`    MAX config: ${maxConfig ? 'Present' : 'Missing'}`);
  console.log(`    Discord config: ${discordConfig ? 'Present' : 'Missing'}`);

  if (!telegramConfig || !maxConfig || !discordConfig) {
    throw new Error('Default configurations should exist for all platforms');
  }

  console.log(`    Telegram interval: ${telegramConfig.interval}ms`);
  console.log(`    MAX interval: ${maxConfig.interval}ms`);
  console.log(`    Discord interval: ${discordConfig.interval}ms`);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É —Ä–∞–∑–Ω—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º —Ä–∞–∑–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
  if (telegramConfig.interval === maxConfig.interval && maxConfig.interval === discordConfig.interval) {
    console.warn('    Warning: All platforms have same interval');
  }
}

async function testBasicPollingOperations() {
  console.log('  Testing basic polling operations...');

  const manager = PollingManager.getInstance();
  const mockAdapter = new MockAdapter('telegram');
  const adapterId = 'test-basic';

  // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ polling
  manager.stopAllPolling();

  // 1. –ó–∞–ø—É—Å–∫ polling
  manager.startPolling(adapterId, mockAdapter as any);
  console.log(`    After start - Active: ${manager.isPollingActive(adapterId)}`);

  if (!manager.isPollingActive(adapterId)) {
    throw new Error('Polling should be active after start');
  }

  // 2. –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö polls
  await new Promise(resolve => setTimeout(resolve, 2000));

  // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ polling –≤—ã–ø–æ–ª–Ω—è–ª—Å—è
  console.log(`    Poll count: ${mockAdapter.getPollCount()}`);

  if (mockAdapter.getPollCount() === 0) {
    throw new Error('Polling should have been executed');
  }

  // 4. –û—Å—Ç–∞–Ω–æ–≤–∫–∞ polling
  manager.stopPolling(adapterId);
  console.log(`    After stop - Active: ${manager.isPollingActive(adapterId)}`);

  if (manager.isPollingActive(adapterId)) {
    throw new Error('Polling should be inactive after stop');
  }
}

async function testConfigurationManagement() {
  console.log('  Testing configuration management...');

  const manager = PollingManager.getInstance();
  const mockAdapter = new MockAdapter('telegram');
  const adapterId = 'test-config';

  // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ polling
  manager.stopAllPolling();

  // –ó–∞–ø—É—Å–∫–∞–µ–º —Å –∫–∞—Å—Ç–æ–º–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π
  const customConfig = {
    interval: 3000,
    timeout: 45000,
    maxRetries: 2,
    backoffMultiplier: 1.5,
    enabled: true
  };

  manager.startPolling(adapterId, mockAdapter as any, customConfig);

  // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
  const config = manager.getPollingConfig(adapterId);
  console.log(`    Custom interval: ${config?.interval}ms`);
  console.log(`    Custom timeout: ${config?.timeout}ms`);
  console.log(`    Custom retries: ${config?.maxRetries}`);

  if (!config || config.interval !== 3000) {
    throw new Error('Custom configuration should be applied');
  }

  // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
  manager.updatePollingConfig(adapterId, { interval: 5000 });
  const updatedConfig = manager.getPollingConfig(adapterId);
  console.log(`    Updated interval: ${updatedConfig?.interval}ms`);

  if (!updatedConfig || updatedConfig.interval !== 5000) {
    throw new Error('Configuration should be updated');
  }

  // –û—á–∏—Å—Ç–∫–∞
  manager.stopPolling(adapterId);
}

async function testStatisticsCollection() {
  console.log('  Testing statistics collection...');

  const manager = PollingManager.getInstance();
  const mockAdapter = new MockAdapter('telegram');
  const adapterId = 'test-stats';

  // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ polling
  manager.stopAllPolling();

  // –ó–∞–ø—É—Å–∫–∞–µ–º polling
  manager.startPolling(adapterId, mockAdapter as any, { interval: 500 });

  // –ñ–¥–µ–º –¥–ª—è –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  await new Promise(resolve => setTimeout(resolve, 3000));

  // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  const stats = manager.getPollingStats(adapterId);
  console.log(`    Stats available: ${stats.length > 0 ? 'Yes' : 'No'}`);

  if (stats.length > 0) {
    const stat = stats[0];
    console.log(`    Platform: ${stat.platform}`);
    console.log(`    Active: ${stat.isActive}`);
    console.log(`    Request count: ${stat.requestCount}`);
    console.log(`    Error count: ${stat.errorCount}`);
    console.log(`    Uptime: ${Math.round(stat.uptime / 1000)}s`);
    console.log(`    Avg response time: ${Math.round(stat.averageResponseTime)}ms`);

    if (stat.requestCount === 0) {
      throw new Error('Should have some requests recorded');
    }
  } else {
    throw new Error('Statistics should be available');
  }

  // –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
  const overallStats = manager.getOverallStats();
  console.log(`    Total active: ${overallStats.totalActive}`);
  console.log(`    Total requests: ${overallStats.totalRequests}`);

  // –û—á–∏—Å—Ç–∫–∞
  manager.stopPolling(adapterId);
}

async function testErrorHandling() {
  console.log('  Testing error handling...');

  const manager = PollingManager.getInstance();
  const mockAdapter = new MockAdapter('telegram');
  const adapterId = 'test-error';

  // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ polling
  manager.stopAllPolling();

  // –ó–∞–ø—É—Å–∫–∞–µ–º polling —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—à–∏–±–æ–∫
  manager.startPolling(adapterId, mockAdapter as any, {
    interval: 500,
    maxRetries: 2,
    enabled: true
  });

  // –ñ–¥–µ–º, –ø–æ–∫–∞ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç –æ—à–∏–±–∫–∞ (–Ω–∞ 5-–º poll) –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞
  await new Promise(resolve => setTimeout(resolve, 4000));

  const stats = manager.getPollingStats(adapterId);
  if (stats.length > 0) {
    console.log(`    Errors recorded: ${stats[0].errorCount > 0 ? 'Yes' : 'No'}`);
    console.log(`    Error count: ${stats[0].errorCount}`);
    console.log(`    Still active: ${stats[0].isActive ? 'Yes' : 'No'}`);

    if (stats[0].errorCount === 0) {
      console.warn('    Warning: No errors recorded (might be timing issue)');
    }
  }

  // –û—á–∏—Å—Ç–∫–∞
  manager.stopPolling(adapterId);
}

async function testHealthMonitoring() {
  console.log('  Testing health monitoring...');

  const manager = PollingManager.getInstance();
  const mockAdapter1 = new MockAdapter('telegram');
  const mockAdapter2 = new MockAdapter('max');

  // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ polling
  manager.stopAllPolling();

  // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –∞–¥–∞–ø—Ç–µ—Ä–æ–≤
  manager.startPolling('adapter1', mockAdapter1 as any);
  manager.startPolling('adapter2', mockAdapter2 as any);

  // –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –¥–ª—è –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
  await new Promise(resolve => setTimeout(resolve, 2000));

  // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç—É—Å –∑–¥–æ—Ä–æ–≤—å—è
  const healthStatus = manager.getHealthStatus();
  console.log(`    System healthy: ${healthStatus.healthy ? 'Yes' : 'No'}`);
  console.log(`    Issues found: ${healthStatus.issues.length}`);
  console.log(`    Recommendations: ${healthStatus.recommendations.length}`);

  if (healthStatus.issues.length > 0) {
    console.log(`    Sample issue: ${healthStatus.issues[0]}`);
  }

  if (healthStatus.recommendations.length > 0) {
    console.log(`    Sample recommendation: ${healthStatus.recommendations[0]}`);
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ø–∏—Å–æ–∫ –∞–¥–∞–ø—Ç–µ—Ä–æ–≤
  const adapters = manager.getPollingAdapters();
  console.log(`    Active adapters: ${adapters.length}`);

  if (adapters.length !== 2) {
    throw new Error(`Expected 2 adapters, got ${adapters.length}`);
  }

  // –û—á–∏—Å—Ç–∫–∞
  manager.stopAllPolling();
}

// –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤
if (require.main === module) {
  testPollingSimple()
    .then(results => {
      if (results.failed === 0) {
        console.log('\nüéâ All polling system tests passed!');
        process.exit(0);
      } else {
        console.log('\nüí• Some polling system tests failed!');
        process.exit(1);
      }
    })
    .catch(error => {
      console.error('\nüí• Polling system test suite failed:', error);
      process.exit(1);
    });
}

export { testPollingSimple };